{
  "name": "simple-peer",
  "description": "Simple one-to-one WebRTC video/voice and data channels",
  "version": "3.6.9",
  "author": {
    "name": "Feross Aboukhadijeh",
    "email": "feross@feross.org",
    "url": "http://feross.org/"
  },
  "bugs": {
    "url": "https://github.com/feross/simple-peer/issues"
  },
  "dependencies": {
    "debug": "^2.1.0",
    "extend.js": "0.0.2",
    "hat": "0.0.3",
    "inherits": "^2.0.1",
    "is-typedarray": "0.0.0",
    "once": "^1.3.1",
    "typedarray-to-buffer": "^3.0.0"
  },
  "devDependencies": {
    "browserify": "^8.0.3",
    "concat-stream": "^1.4.6",
    "tape": "^3.0.3",
    "uglify-js": "^2.4.15",
    "zuul": "^1.11.1"
  },
  "homepage": "http://webtorrent.io",
  "keywords": [
    "webrtc",
    "p2p",
    "data channel",
    "data channels",
    "data",
    "video",
    "voice",
    "peer",
    "stream",
    "peer-to-peer",
    "data channel stream",
    "webrtc stream",
    "peer"
  ],
  "license": "MIT",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/feross/simple-peer.git"
  },
  "scripts": {
    "test": "zuul -- test/*.js",
    "test-local": "zuul --local -- test/*.js",
    "build": "browserify -s SimplePeer -r ./ | uglifyjs -c warnings=false -m > simplepeer.bundle.js"
  },
  "testling": {
    "files": "test/*.js"
  },
  "readme": "# simple-peer [![travis](https://img.shields.io/travis/feross/simple-peer.svg?style=flat)](https://travis-ci.org/feross/simple-peer) [![npm](https://img.shields.io/npm/v/simple-peer.svg?style=flat)](https://npmjs.org/package/simple-peer) [![npm downloads](https://img.shields.io/npm/dm/simple-peer.svg?style=flat)](https://npmjs.org/package/simple-peer) [![gittip](https://img.shields.io/gittip/feross.svg?style=flat)](https://www.gittip.com/feross/)\n\n#### Simple WebRTC video/voice and data channels.\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/feross-simple-peer.svg)](https://saucelabs.com/u/feross-simple-peer)\n\n## features\n\n- **super simple** API for working with [WebRTC](https://en.wikipedia.org/wiki/WebRTC)\n- supports **video/voice streams**\n- supports **data channel**\n  - text and binary data\n  - optionally, treat data channel as a node.js [duplex stream](http://nodejs.org/api/stream.html)\n- supports advanced options like:\n  - enable/disable [trickle ICE candidates](http://webrtchacks.com/trickle-ice/)\n  - manually set config and constraints options\n\nThis module works great in the browser with [browserify](http://browserify.org/).\n\n**Note:** If you're **NOT** using browserify, then use the included standalone file\n`simplepeer.bundle.js`. This exports a `SimplePeer` function on `window`.\n\n## install\n\n```\nnpm install simple-peer\n```\n\n## usage\n\nThese examples create two peers in the same page.\n\nIn a real-world application, the sender and receiver `Peer` instances would exist in separate browsers. A \"signaling server\" (usually implemented with websockets) would be used to exchange signaling data between the two browsers until a peer-to-peer connection is established.\n\n### data channels\n\n```js\nvar SimplePeer = require('simple-peer')\n\nvar peer1 = new SimplePeer({ initiator: true })\nvar peer2 = new SimplePeer()\n\npeer1.on('signal', function (data) {\n  // when peer1 has signaling data, give it to peer2\n  peer2.signal(data)\n})\n\npeer2.on('signal', function (data) {\n  // same as above, but in reverse\n  peer1.signal(data)\n})\n\npeer1.on('ready', function () {\n  // wait for 'ready' event before using the data channel\n  peer1.send('hey peer2, how is it going?')\n})\n\npeer2.on('message', function (data) {\n  // got a data channel message\n  console.log('got a message from peer1: ' + data)\n})\n```\n\n### video/voice\n\nVideo/voice is also super simple! In this example, peer1 sends video to peer2.\n\n```js\nvar SimplePeer = require('simple-peer')\n\n// get video/voice stream\nnavigator.getUserMedia({ video: true, audio: true }, gotMedia, function () {})\n\nfunction gotMedia (stream) {\n  var peer1 = new SimplePeer({ initiator: true, stream: stream })\n  var peer2 = new SimplePeer()\n\n  peer1.on('signal', function (data) {\n    peer2.signal(data)\n  })\n\n  peer2.on('signal', function (data) {\n    peer1.signal(data)\n  })\n\n  peer2.on('stream', function (stream) {\n    // got remote video stream, now let's show it in a video tag\n    var video = document.querySelector('video')\n    video.src = window.URL.createObjectURL(stream)\n    video.play()\n  })\n}\n```\n\nFor two-way video, simply pass a `stream` option into both `Peer` constructors. Simple!\n\n## real-world apps that use `simple-peer`\n\n- [Instant](https://instant.io) - Secure, anonymous, streaming file transfer\n- [WebTorrent](http://webtorrent.io) - Streaming torrent client in the browser\n- [PusherTC](http://pushertc.herokuapp.com) - Video chat with using Pusher. See [guide](http://blog.carbonfive.com/2014/10/16/webrtc-made-simple/).\n- [lxjs-chat](https://github.com/feross/lxjs-chat) - Omegle-like video chat site\n- *Your app here! - send a PR!*\n\n## api\n\n### `peer = new SimplePeer([opts])`\n\nCreate a new WebRTC peer connection.\n\nA \"data channel\" for text/binary communication is always established, because it's cheap and often useful. For video/voice communication, pass the `stream` option.\n\nIf `opts` is specified, then the default options (shown below) will be overridden.\n\n```\n{\n  initiator: false,\n  stream: false,\n  config: { iceServers: [ { url: 'stun:23.21.150.121' } ] },\n  constraints: {},\n  channelName: '<random string>',\n  trickle: true\n}\n```\n\nThe options do the following:\n\n- `initiator` - set to true if this is the initiating peer\n- `stream` - if video/voice is desired, pass stream returned from `getUserMedia`\n- `config` - custom webrtc configuration\n- `constraints` - custom webrtc video/voice constaints\n- `channelName` - custom webrtc data channel name\n- `trickle` - set to `false` to disable [trickle ICE](http://webrtchacks.com/trickle-ice/) and get a single 'signal' event (slower)\n\n### `peer.signal(data)`\n\nCall this method whenever the remote peer emits a `peer.on('signal')` event.\n\nThe `data` will be a `String` that encapsulates a webrtc offer, answer, or ice candidate. These messages help the peers to eventually establish a direct connection to each other. The contents of these strings are an implementation detail that can be ignored by the user of this module; simply pass the data from 'signal' events to the remote peer, call `peer.signal(data)`, and everything will just work.\n\n### `peer.send(data)`\n\nSend text/binary data to the remote peer. `data` can be any of several types: `String`, `Buffer` (see [buffer](https://github.com/feross/buffer)), TypedArrayView (Uint8Array, etc.), or ArrayBuffer.\n\nNote: this method should not be called until the `peer.on('ready')` event has fired.\n\n### `peer.destroy([onclose])`\n\nDestroy and cleanup this peer connection.\n\nIf the optional `onclose` parameter is passed, then it will be registered as a listener on the 'close' event.\n\n### `stream = peer.getDataStream()`\n\nReturns a duplex stream which reads/writes to the data channel.\n\nVery handy for treating the data channel just like any other node.js stream!\n\n\n## events\n\n\n### `peer.on('signal', function (data) {})`\n\nFired when the peer wants to send signaling data to the remote peer.\n\n**It is the responsibility of the application developer (that's you!) to get this data to the other peer.** This usually entails using a websocket signaling server. Then, simply call `peer.signal(data)` on the remote peer.\n\n### `peer.on('ready', function () {})`\n\nFired when the peer connection and data channel are ready to use.\n\n### `peer.on('message', function (data) {})`\n\nReceived a message from the remote peer (via the data channel).\n\n`data` will be either a `String` or a `Buffer/Uint8Array` (see [buffer](https://github.com/feross/buffer)).\n\n### `peer.on('stream', function (stream) {})`\n\nReceived a remote video stream, which can be displayed in a video tag:\n\n```js\npeer.on('stream', function (stream) {\n  var video = document.createElement('video')\n  video.src = window.URL.createObjectURL(stream)\n  document.body.appendChild(video)\n  video.play()\n})\n```\n\n### `peer.on('close', function () {})`\n\nCalled when the peer connection has closed.\n\n### `peer.on('error', function (err) {})`\n\nFired when a fatal error occurs. Usually, this means bad signaling data was received from the remote peer.\n\n`err` is an `Error` object.\n\n## connecting more than 2 peers?\n\nThe simplest way to do that is to create a full-mesh topology. That means that every peer\nopens a connection to every other peer. To illustrate:\n\n![full mesh topology](img/full-mesh.png)\n\nTo broadcast a message, just iterate over all the peers and call `peer.send`.\n\nSo, say you have 3 peers. Then, when a peer wants to send some data it must send it 2\ntimes, once to each of the other peers. So you're going to want to be a bit careful about\nthe size of the data you send.\n\nFull mesh topologies don't scale well when the number of peers is very large. The total\nnumber of edges in the network will be ![full mesh formula](img/full-mesh-formula.png)\nwhere `n` is the number of peers.\n\nFor clarity, here is the code to connect 3 peers together:\n\n#### Peer 1\n\n```js\n// These are peer1's connections to peer2 and peer3\nvar peer2 = new SimplePeer({ initiator: true })\nvar peer3 = new SimplePeer({ initiator: true })\n\npeer2.on('signal', function (data) {\n  // send this signaling data to peer2 somehow\n})\n\npeer2.on('ready', function () {\n  peer2.send('hi peer2, this is peer1')\n})\n\npeer2.on('message', function (data) {\n  console.log('got a message from peer2: ' + data)\n})\n\npeer3.on('signal', function (data) {\n  // send this signaling data to peer3 somehow\n})\n\npeer3.on('ready', function () {\n  peer3.send('hi peer3, this is peer1')\n})\n\npeer3.on('message', function (data) {\n  console.log('got a message from peer3: ' + data)\n})\n```\n\n#### Peer 2\n\n```js\n// These are peer2's connections to peer1 and peer3\nvar peer1 = new SimplePeer()\nvar peer3 = new SimplePeer({ initiator: true })\n\npeer1.on('signal', function (data) {\n  // send this signaling data to peer1 somehow\n})\n\npeer1.on('ready', function () {\n  peer1.send('hi peer1, this is peer2')\n})\n\npeer1.on('message', function (data) {\n  console.log('got a message from peer1: ' + data)\n})\n\npeer3.on('signal', function (data) {\n  // send this signaling data to peer3 somehow\n})\n\npeer3.on('ready', function () {\n  peer3.send('hi peer3, this is peer2')\n})\n\npeer3.on('message', function (data) {\n  console.log('got a message from peer3: ' + data)\n})\n```\n\n#### Peer 3\n\n```js\n// These are peer3's connections to peer1 and peer2\nvar peer1 = new SimplePeer()\nvar peer2 = new SimplePeer()\n\npeer1.on('signal', function (data) {\n  // send this signaling data to peer1 somehow\n})\n\npeer1.on('ready', function () {\n  peer1.send('hi peer1, this is peer3')\n})\n\npeer1.on('message', function (data) {\n  console.log('got a message from peer1: ' + data)\n})\n\npeer2.on('signal', function (data) {\n  // send this signaling data to peer2 somehow\n})\n\npeer2.on('ready', function () {\n  peer2.send('hi peer2, this is peer3')\n})\n\npeer2.on('message', function (data) {\n  console.log('got a message from peer2: ' + data)\n})\n```\n\n## license\n\nMIT. Copyright (c) [Feross Aboukhadijeh](http://feross.org).\n",
  "readmeFilename": "README.md",
  "_id": "simple-peer@3.6.9",
  "_shasum": "ae42850f292c014d47e65992e16c508dc39ca3e9",
  "_from": "simple-peer@",
  "_resolved": "https://registry.npmjs.org/simple-peer/-/simple-peer-3.6.9.tgz"
}
